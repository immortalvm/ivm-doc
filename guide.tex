\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[includeheadfoot,margin=2cm]{geometry}
\usepackage{times}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{mathptmx}
\usepackage{tikz}
\usepackage{xspace}
\frenchspacing
\renewcommand{\ttdefault}{cmtt}
\author{Thor Kristoffersen}
\date{\today}
\title{Guide to Building a Machine}
\newcommand{\PC}{\textbf{program counter}\xspace}
\newcommand{\SP}{\textbf{stack pointer}\xspace}
\newcommand{\TERM}{\textbf{terminated}\xspace}
\newcommand{\F}{\textbf{false}\xspace}
\newcommand{\T}{\textbf{true}\xspace}
\newcommand{\num}[1]{\texttt{#1}\xspace}
\newcommand{\hex}[1]{\num{#1}$_{\textup{\tiny\hskip-1ex 16}}$\xspace}
\newcommand{\bin}[1]{\num{#1}$_{\textup{\tiny\hskip-1ex 2}}$\xspace}
\newcommand{\comment}[1]{\begin{quote}[\textit{#1}]\end{quote}}
\newcommand{\op}[1]{#1}
\newcommand{\EXIT}     [1]{\op{\hex{00}}\xspace}
\newcommand{\NOP}      [1]{\op{\hex{01}}\xspace}
\newcommand{\JUMP}     [1]{\op{\hex{02}}\xspace}
\newcommand{\JUMPZERO} [1]{\op{\hex{03}}\xspace}
\newcommand{\SETSP}    [1]{\op{\hex{04}}\xspace}
\newcommand{\GETPC}    [1]{\op{\hex{05}}\xspace}
\newcommand{\GETSP}    [1]{\op{\hex{06}}\xspace}
\newcommand{\PUSHZ}    [1]{\op{\hex{07}}\xspace}
\newcommand{\PUSHB}    [1]{\op{\hex{08}}\xspace}
\newcommand{\PUSHS}    [1]{\op{\hex{09}}\xspace}
\newcommand{\PUSHI}    [1]{\op{\hex{0A}}\xspace}
\newcommand{\PUSHL}    [1]{\op{\hex{0B}}\xspace}
\newcommand{\READFRAME}[1]{\op{\hex{38}}\xspace}
\newcommand{\READPIXEL}[1]{\op{\hex{39}}\xspace}
\begin{document}

\maketitle

\noindent
This film contains programs that can be executed on a machine.
The purpose of this part of the film is to guide you through the process of building this machine.
To understand this guide, you need to have knowledge of basic 20th century mathematics and physics.

You will start by building a very simple machine, and then you will extend this machine through several stages, so that by the end you will have a fully functional machine.

When you have finished the machine, you are not quite ready to run programs yet.
First you will need to install in the machine an initial program, which is supplied here.

\comment{Provide time estimates for the above tasks.}

\section{Building the Machine}
\label{sec:building-machine}

By following the instructions here, you can develop the machine through several stages, each stage leading to a more capable machine than the preceding one.
Only when you have obtained the correct test results for each stage should you proceed with the following stage.

Number systems used here include decimal, binary, and hexadecimal.
All non-decimal numbers are explictly indicated by subscripts indicating the number base in decimal.
Further detail on binary and hexadecimal notation can be found in Appendixes~\ref{sec:binary-notation} and \ref{sec:hexadecimal-notation}.

\subsection{Storage}

To build the machine, you first need storage to represent state consisting of binary digits (bits).
A storage \emph{element} is a group of bits forming a unit with respect to naming.
The number of bits is called the \emph{size} of the element.
Each element has a unique name, so that it can be unambiguously referred to, and the contents can be retrieved or stored in one atomic operation.
This machine employs element sizes of 1, 8, and 64 bits.
The storage is divided into three categories:
\begin{description}
\item[Memory] 
The memory consists of a number of 8-bit elements, up to a maximum of $2^{64}$.
Each memory element is named by an integer in the range from $0$ to $2^{64} - 1$.
When testing the storage, and when building the first versions of the machine, we will limit the number of memory elements to $2^8$.
\item[Registers] 
There are two registers, named respectively the \PC and the \SP.
Both of these are 64-bit elements.
The contents of either register are interpreted as a non-negative integer referring to a memory element.
\item[Flags] 
There is one flag, named the \TERM flag, which is a 1-bit element.
This bit represents a value of \T or \F.
The machine will stop if and only if this has a value of \T.
\end{description}
In addition to the storage elements defined here, it is sometimes necessary to use additional storage elements temporarily.
These will be introduced whenever needed and are named by single letters.

\subsection{Storage Operations}
\label{sec:storage-operations}

We need to define a few terms to talk about storage operations.
\begin{itemize}
\item ``The value of an element'' means the contents as retrieved from that element.
\item ``To set the value of an element to $x$'' means to store the value of $x$ in that element.
\item ``To increment an element by $n$'' means to set the value of $x$ to the value of the element and then set that element to $(x + n) \mod s$, where $s$ is the size of the element.
\item ``To decrement an element by $n$'' means to set the value of $x$ to the value of the element and then set that element to $(x - n) \mod s$, where $s$ is the size of the element.
\item ``The value of \emph{byte} $b$ in $x$'' means the contents of the 8-bit subsequence of $x$ from bit number $8b+7$ to bit number $8b$.
\item ``To set \emph{byte} $b$ in $x$ to $y$'' means to store the 8-bit sequence $y$ in the 8-bit subsequence of $x$ from bit number $8b+7$ to bit number $8b$, while keeping all other bits of $x$ unchanged.
\end{itemize}
These should be basic operations in your implementation.

\subsection{Testing the Storage}

To test that the storage works as it should, do the following tests several times for every storage element:
\begin{enumerate}
\item Verify that storing and getting the value of an element works.
  \begin{enumerate}
  \item Select a random bit sequence, $x$, of the same size, $s$, as the storage element.
  \item Store this bit sequence in the element.
  \item Verify that the value of the element is $x$.
  \end{enumerate}
\item Verify that your operations for incrementing and decrementing an element work.
  \begin{enumerate}
  \item Select a random bit sequence, $n$, of size $s$, different from zero.
  \item Increment the element by $n$.
  \item Verify that the value of the element is $(x + n) \mod 2^s$.
  \item Decrement the element by $n$.
  \item Verify that the value of the element is $x$.
  \end{enumerate}
\item Verify that your byte operations work for every byte, $b$, from $0$ to $7$.
  \begin{enumerate}
  \item Get the value of all bytes in $x$.
  \item Select a random bit sequence, $y$, of size $8$, different from the value of byte $b$.
  \item Set byte $b$ of the element to $y$.
  \item Verify that the value of $b$ is $y$.
  \item Verify that the values of all the other bytes are unchanged.
  \end{enumerate}
\end{enumerate}

\subsection{A Couple of Basic Procedures}

Some basic procedures are heavily used by the machine.
These use the storage operations in Section~\ref{sec:storage-operations}.

\subsubsection{Push 64-bit Value}

Assume that we have an existing 64-bit element called $x$.
The expression ``Push the 64-bit value $x$'', means to do the following steps:
\begin{enumerate}
\item Set the value of element $i$ to 8;
\item Do the following 8 times:
  \begin{enumerate}
  \item Decrement $i$ by 1.
  \item Decrement \SP by 1.
  \item Set memory element \SP to byte $i$ of $x$.
  \end{enumerate}
\end{enumerate}

\subsubsection{Pop 64-bit Value}

The expression ``Pop the 64-bit value $x$'', means to do the following steps:
\begin{enumerate}
\item Set the value of the 64-bit element $x$ to 0;
\item Set the value of element $i$ to 0;
\item Do the following 8 times:
  \begin{enumerate}
  \item Set byte $i$ of $x$ to memory element \SP.
  \item Increment $i$ by 1.
  \item Increment \SP by 1.
  \end{enumerate}
\end{enumerate}
The 64-bit element $x$ can now be used by other procedures.

\subsection{Testing the Basic Procedures}

To test the basic procedures, do as follows:
\begin{enumerate}
\item Set \SP to \hex{0000000000000008}.
\item Set the 64-bit value $x$ to \hex{0123456789ABCDEF}.
\item Push the 64-bit value $x$.
\item Pop the 64-bit value $y$.
\item Verify that $x=y$.
\item Verify that the value of \SP is \hex{0000000000000008}.
\item Verify that the contents of the first eight memory elements are as in the following table.
\end{enumerate}

\begin{center}
  \begin{tabular}{@{}lr@{}}
    \hline
    Storage element        & Value    \\
    \hline
    \hex{0000000000000000} & \hex{EF} \\
    \hex{0000000000000001} & \hex{CD} \\
    \hex{0000000000000002} & \hex{AB} \\
    \hex{0000000000000003} & \hex{89} \\
    \hex{0000000000000004} & \hex{67} \\
    \hex{0000000000000005} & \hex{45} \\
    \hex{0000000000000006} & \hex{23} \\
    \hex{0000000000000007} & \hex{01} \\
    \hline
  \end{tabular}
\end{center}


\subsection{First Version of The Machine}

You can now proceed with implementing a basic version of the machine.
For practical reasons we will build this version of the machine with a fixed memory size of $2^{8}$ elements.

Machine operation proceeds through two phases: first the storage is initialized, and then the main procedure is executed.

\subsubsection{Storage Initialization}

To initialize the storage, you need to set registers and flags to predefined values.
The \PC is set to the address of the first memory element, that is, $0$.
The \SP is set to the first element beyond the range of addressable elements, that is, $2^{8}$ in this version of the machine.
The values are given in the table below.

\begin{center}
  \begin{tabular}{@{}ll@{}}
    \hline
    Register or flag & Value                   \\
    \hline
    \PC              & \hex{0000000000000000}  \\
    \SP              & \hex{0000000000000100}  \\
    \TERM            & \F                      \\
    \hline
  \end{tabular}
\end{center}

\subsubsection{The Main Procedure}

When you have initialized the storage, simply execute the main procedure repeatedly until the value of the \TERM flag is \T.
The main procedure must carry out the following steps.
\begin{enumerate}
\item Set the 64-bit value $p$ to the value of \PC.
\item Increment \PC.
\item Retrieve the 8-bit value of memory element $p$.
\item\label{itm:main-case} If the value is
  \begin{itemize}
  \item \EXIT{}, then set the value of  \TERM to \T.
  \item \NOP{}, then do nothing.
  \item \JUMP{}, then do as follows:
    \begin{enumerate}
    \item Pop the 64-bit value $a$.
    \item Set \PC to $a$.
    \end{enumerate}
  \item \SETSP, then do as follows:
    \begin{enumerate}
    \item Pop the 64-bit value $a$.
    \item Set \SP to $a$.
    \end{enumerate}
  \item \GETPC, then do as follows:
    \begin{enumerate}
    \item Set the 64-bit value $a$ to \PC.
    \item Push the 64-bit value $a$.
    \end{enumerate}
  \item \GETSP, then do as follows:
    \begin{enumerate}
    \item Set the 64-bit value $a$ to \SP.
    \item Push the 64-bit value $a$.
    \end{enumerate}
  \item \PUSHL{}, then do as follows:
    \begin{enumerate}
    \item Set the 64-bit value of $a$ to 0.
      \begin{enumerate}
      \item Set the value of byte $i$ of $a$ to the value of memory element \PC.
      \item Increment \PC by 1.
      \end{enumerate}
    \item Push the 64-bit value $a$.
    \end{enumerate}
  \end{itemize}
\end{enumerate}

\subsubsection{Testing the Basic Machine}

To test the machine, first initialize all memory elements to the value \hex{00}, and then set the following memory elements to the provided values.

\begin{center}
  \begin{tabular}{@{}ll@{}}
    \hline
    Memory element         & Value \\
    \hline
    \hex{0000000000000000} & \hex{01} \\
    \hex{0000000000000001} & \hex{0B} \\
    \hex{0000000000000002} & \hex{13} \\
    \hex{0000000000000003} & \hex{00} \\
    \hex{0000000000000004} & \hex{00} \\
    \hex{0000000000000005} & \hex{00} \\
    \hex{0000000000000006} & \hex{00} \\
    \hex{0000000000000007} & \hex{00} \\
    \hex{0000000000000008} & \hex{00} \\
    \hex{0000000000000009} & \hex{00} \\
    \hex{000000000000000A} & \hex{02} \\
    \hex{000000000000000B} & \hex{00} \\
    \hex{000000000000000C} & \hex{00} \\
    \hex{000000000000000D} & \hex{00} \\
    \hex{000000000000000E} & \hex{00} \\
    \hex{000000000000000F} & \hex{00} \\
    \hline
  \end{tabular}
  \hfil
  \begin{tabular}{@{}ll@{}}
    \hline
    Memory element         & Value \\
    \hline
    \hex{0000000000000010} & \hex{00} \\
    \hex{0000000000000011} & \hex{00} \\
    \hex{0000000000000012} & \hex{00} \\
    \hex{0000000000000013} & \hex{06} \\
    \hex{0000000000000014} & \hex{05} \\
    \hex{0000000000000015} & \hex{0B} \\
    \hex{0000000000000016} & \hex{F8} \\
    \hex{0000000000000017} & \hex{00} \\
    \hex{0000000000000018} & \hex{00} \\
    \hex{0000000000000019} & \hex{00} \\
    \hex{000000000000001A} & \hex{00} \\
    \hex{000000000000001B} & \hex{00} \\
    \hex{000000000000001C} & \hex{00} \\
    \hex{000000000000001D} & \hex{00} \\
    \hex{000000000000001E} & \hex{04} \\
    \hex{000000000000001F} & \hex{00} \\
    \hline
  \end{tabular}
\end{center}

Now start the machine.
When it terminates, all storage elements should remain unchanged, except the following ones, which should have the indicated values.

\begin{center}
  \begin{tabular}{@{}lr@{}}
    \hline
    Storage element        & Value                   \\
    \hline
    \PC                    & \hex{0000000000000020}  \\
    \SP                    & \hex{00000000000000F8}  \\
    \TERM                  & \T                      \\
    \hex{00000000000000E8} & \hex{F8} \\
    \hex{00000000000000F0} & \hex{15} \\
    \hex{00000000000000F9} & \hex{01} \\
    \hline
  \end{tabular}
\end{center}

If the machine does not terminate or you did not get exactly the above results, the implementation is incorrect.

\subsection{Second Version of the Machine}

TODO

\section{Building the Devices}
\label{sec:building-devices}

At this point you should have a machine with fully functional computational capabilities.
What's missing are the devices that allow the machine to consume data from its environment and to produce data to its environment.
There are four devices:
\begin{itemize}
\item The \emph{Image Input} device allows input of images as a two-dimensional matrix of gray-scale values.
  This device is very important, because it is what enables the machine to load programs encoded as images on the film.
\item The \emph{Image Output} device allows output of color images.
  Moving images are supported by outputting a time series of still images.
\item The \emph{Audio Output} device allows output of audio signals as a time series of amplitude values.
\item The \emph{Text Output} device allows output of text as a stream of characters.
\end{itemize}
The descriptions below will only explain the correspondence between machine events and real world events.
It is up to you to make sure that the interpretation of real world events is faithfully implemented.

\subsection{Image Input}

The \emph{Image Input} device allows input of images as a two-dimensional matrix of gray-scale values.
The following figure shows an example of such a matrix, consisting of 32 picture elements arranged in 8 columns and 4 rows.
\begin{center}
  \begin{tikzpicture}[scale=0.75]
    \foreach \x in {0,...,7}
    \foreach \y in {0,...,3}
    {
      \fill (\x,\y) circle [radius=2mm,fill=black,draw] {};
    }
    \foreach \x in {0,...,7} \draw (\x, -1) node {\x};
    \foreach \y in {0,...,3} \draw (-1, 3 - \y) node {\y};
    \draw (-0.5,-0.5) -- (7.5,-0.5) -- (7.5,3.5) -- (-0.5,3.5) -- cycle;
  \end{tikzpicture}
\end{center}
As shown, both columns and rows are numbered consecutively, starting at 0.
The spacing between the picture elements is uniform in both horizontal and vertical directions.
Each picture element represents the intensity of light at that position in the image, represented as one of 256 intensity levels, from 0 (minimum intensity) to 255 (maximum intensity).
Values between 0 and 255 represent intermediate intensities between these extremes.

In order to implement the image input device, you will need to two extra cases to step \ref{itm:main-case} of the main procedure.

\begin{enumerate}
  \setcounter{enumi}{3}
\item If the value is
  \begin{itemize}
  \item \hex{38}, then do as follows:
    \begin{enumerate}
    \item Ready the next image to be consumed by the machine.
    \item Set the 64-bit value of $c$ to the number of columns in the image.
    \item Push the 64-bit value $c$.
    \item Set the 64-bit value of $r$ to the number of rows in the image.
    \item Push the 64-bit value $r$.
    \end{enumerate}
  \item \hex{39}, then do as follows:
    \begin{enumerate}
    \item Pop the 64-bit value $x$.
    \item Pop the 64-bit value $y$.
    \item Find the intensity of light in the image at column $x$ and row $y$, represented as an 8-bit value, $z$.
    \item Decrement \SP.
    \item Set the value of memory element \SP to $z$.
    \end{enumerate}
  \end{itemize}
\end{enumerate}

\subsection{Image Output}

\subsection{Audio Output}

\subsection{Text Output}

\section{Installing the Initial Program}

\appendix

\section{Binary Notation}
\label{sec:binary-notation}

Each storage element contains a binary value, that is, a sequence of binary digits that can be retrieved or modified in one atomic operation.

In this documentation, individual binary digits are referred to using non-negative integers, listed in decreasing order.  For example,
\begin{itemize}
\item In the binary number \bin{1000}, bit number 3 is 1.
\item In the binary number \bin{0001}, bit number 0 is 1.
\end{itemize}

When binary values represent integers, each bit represents two to the power of the bit number.
In other words, bit number 0 is always the least significant bit.

\section{Hexadecimal Notation}
\label{sec:hexadecimal-notation}

For convenience, binary numbers are normally written in hexadecimal notation.
Each hexadecimal digit corresponds to a group of four binary digits, as shown in the following table.

\begin{center}
  \begin{tabular}{@{}ll@{}}
    \hline
    Hexadecimal digit & Group of binary digits \\
    \hline
    \num{0}           & \num{0000}   \\
    \num{1}           & \num{0001}   \\
    \num{2}           & \num{0010}   \\
    \num{3}           & \num{0011}   \\
    \num{4}           & \num{0100}   \\
    \num{5}           & \num{0101}   \\
    \num{6}           & \num{0110}   \\
    \num{7}           & \num{0111}   \\
    \num{8}           & \num{1000}   \\
    \num{9}           & \num{1001}   \\
    \num{A}           & \num{1010}   \\
    \num{B}           & \num{1011}   \\
    \num{C}           & \num{1100}   \\
    \num{D}           & \num{1101}   \\
    \num{E}           & \num{1110}   \\
    \num{F}           & \num{1111}   \\
    \hline
  \end{tabular}
\end{center}

\section{The Initial Program}
\label{sec:initial-program}

\comment{Include a listing in hex of the initial program.}
\end{document}
